# icc_fromcube_fuzzer dictionary — high-signal tokens for .cube LUT format
# Targets all parser branches in CubeFile (iccFromCube.cpp)
#
# Parser flow: parseHeader() → parse3DTable() → ICC profile construction
# Key coverage targets:
#   - Header keyword dispatch (TITLE, LUT_3D_SIZE, DOMAIN_MIN/MAX, etc.)
#   - Empty-line / blank-line / comment handling
#   - getTitle() quoted vs unquoted paths
#   - getNext() whitespace-delimited value parsing
#   - parse3DTable() triplet parsing, comment skipping
#   - Integer overflow in LUT_3D_SIZE (atoll path)
#   - Custom input range → curve sharing logic (per-channel match/mismatch)

# ═══════════════════════════════════════════════════════════════════
# SECTION 1: Header keywords (exact match required by substr())
# ═══════════════════════════════════════════════════════════════════
"TITLE "
"LUT_3D_SIZE "
"LUT_1D_SiZE "
"DOMAIN_MIN "
"DOMAIN_MAX "
"LUT_3D_INPUT_RANGE "
"LUT_IN_VIDEO_RANGE"
"LUT_OUT_VIDEO_RANGE"

# ═══════════════════════════════════════════════════════════════════
# SECTION 2: LUT sizes — exercise atoll() + INT_MAX/<=0 validation
# ═══════════════════════════════════════════════════════════════════
# Valid sizes (parse3DTable requires >= 2)
"2"
"3"
"4"
"5"
"8"
"9"
"16"
"17"
"32"
"33"
"64"
"65"
# Boundary: size=1 rejected by parse3DTable (< 2)
"1"
# Boundary: size=0 rejected by atoll check (<= 0)
"0"
# Large sizes (uint64_t overflow in s*s*s: 1291^3 > UINT_MAX)
"1290"
"1291"
"1292"
"2000"
# Negative size rejected by atoll check (<= 0)
"-1"
"-2"
# INT_MAX overflow via atoll
"2147483647"
"2147483648"
"9999999999999"

# ═══════════════════════════════════════════════════════════════════
# SECTION 3: Float values — exercise atof() in DOMAIN and LUT data
# ═══════════════════════════════════════════════════════════════════
# Standard range
"0.0"
"1.0"
"0.5"
"0.25"
"0.75"
# Non-standard ranges (triggers isCustomInputRange)
"-1.0"
"-0.5"
"2.0"
"1.5"
"3.0"
"100.0"
"-100.0"
# Edge-case floats
"0.0000001"
"0.9999999"
"1e10"
"1e-10"
"-1e38"
"1e38"
"inf"
"-inf"
"nan"
"NaN"

# ═══════════════════════════════════════════════════════════════════
# SECTION 4: Float triplets — exercise parse3DTable() row parsing
# ═══════════════════════════════════════════════════════════════════
"0.0 0.0 0.0"
"1.0 1.0 1.0"
"0.5 0.5 0.5"
"0.0 0.5 1.0"
"1.0 0.0 0.5"
"0.25 0.75 0.5"
"-1.0 2.0 0.0"

# ═══════════════════════════════════════════════════════════════════
# SECTION 5: Per-channel DOMAIN values — exercise curve sharing logic
# ═══════════════════════════════════════════════════════════════════
# Uniform range (all channels same → curves shared)
"DOMAIN_MIN 0.0"
"DOMAIN_MAX 1.0"
# Per-channel with 1 value (fallback: all channels = same)
"DOMAIN_MIN -1.0"
"DOMAIN_MAX 2.0"
# Per-channel with 2 values (ch2 = ch1 fallback)
"DOMAIN_MIN 0.0 0.5"
"DOMAIN_MAX 1.0 2.0"
# Per-channel with 3 values (all independent → 3 separate curves)
"DOMAIN_MIN 0.0 0.5 1.0"
"DOMAIN_MAX 1.0 2.0 3.0"
# Channels match ch0 (pCurve1=pCurve0, pCurve2=pCurve0)
"DOMAIN_MIN 0.5 0.5 0.5"
"DOMAIN_MAX 2.0 2.0 2.0"
# Ch1 differs, ch2 matches ch1 (pCurve2=pCurve1)
"DOMAIN_MIN 0.0 0.5 0.5"
"DOMAIN_MAX 1.0 2.0 2.0"
# Ch1 matches ch0, ch2 differs (pCurve1=pCurve0, new pCurve2)
"DOMAIN_MIN 0.0 0.0 0.5"
"DOMAIN_MAX 1.0 1.0 2.0"
# All three different (new pCurve1, new pCurve2)
"DOMAIN_MIN 0.0 0.3 0.6"
"DOMAIN_MAX 1.0 1.5 2.0"

# LUT_3D_INPUT_RANGE (2-value: min max)
"LUT_3D_INPUT_RANGE 0.0 1.0"
"LUT_3D_INPUT_RANGE -1.0 2.0"
"LUT_3D_INPUT_RANGE 0.0"

# ═══════════════════════════════════════════════════════════════════
# SECTION 6: Comment and whitespace tokens
# ═══════════════════════════════════════════════════════════════════
"# "
"#"
"# Comment text"
"#comment"

# ═══════════════════════════════════════════════════════════════════
# SECTION 7: Title variations — exercise getTitle() quoted/unquoted
# ═══════════════════════════════════════════════════════════════════
"TITLE \"Test LUT\""
"TITLE \"Quoted Title\""
"TITLE Unquoted Title"
"TITLE \"\""
"TITLE "

# ═══════════════════════════════════════════════════════════════════
# SECTION 8: getNext() parser edge cases (whitespace delimited)
# ═══════════════════════════════════════════════════════════════════
# Multiple spaces between values
"0.0  0.0  0.0"
# Leading spaces
" 0.0 0.0 0.0"
# Trailing spaces
"0.0 0.0 0.0 "
# Tab characters (not handled as whitespace by getNext — only spaces)
# Single value (getNext returns empty → parse error path)
"0.5"
# Two values only (second getNext fails → parse error)
"0.5 0.5"

# ═══════════════════════════════════════════════════════════════════
# SECTION 9: Line boundary (MAX_LINE_LEN = 255)
# ═══════════════════════════════════════════════════════════════════
# Long line — exercises the n<MAX_LINE_LEN loop limit
"TITLE \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\""

# ═══════════════════════════════════════════════════════════════════
# SECTION 10: Data line detection (first char triggers fseek break)
# ═══════════════════════════════════════════════════════════════════
# Lines starting with digit/dot/minus trigger break out of header
"0"
"."
"-"
".5 .5 .5"
"-0.5 0.0 1.0"

# ═══════════════════════════════════════════════════════════════════
# SECTION 11: Complete mini-CUBE files — exercise full pipeline
# ═══════════════════════════════════════════════════════════════════
# Minimal valid 2x2x2 CUBE (8 entries)
# With custom domain
# With title and comments
# With video range flags

# --- added by convert-libfuzzer-dict.py ---
"\x01\x04"
"\x0b\x00\x00\x00\x00\x00\x00\x00"
"\xf1\x02"
"\x00\x00"
"\x00\x00~\xc5,\xecQ\xd1"
"\x1b\x00"
"H\x00"
"LUT_3D\xcb\xcb\xcb\xcb\xff"
"\x1c\x00"
"]]]]]]]]]]]]"
"#\x00\x00\x00"
"\x01\x00~\xc5,\xb3\x00\x65"
"DOMAIN\x00t D."
"\xff\xff\x01\xeb"
"\x1f\x00"
"\x00\x00~\xc5,\xe8Q\xcc"
"DOMAIN_MIN T"
"\xff\xff\xff\xff"
"\x00\x00\x00\x00\x00\x00\x00\x00"
"\x01\x00~\xc5,\xe8\x91\xcc"
"\xe8\x02"
"\xff\xff}\xc5,\xb0`s"
"\x0c\x0cLUT_OUT_V"
"\x00\x00\x00\x0f"
"\xdd\x02\x00\x00"
"(\x00"
"\x01\x7f"
"\x0b\x00"
"\xc1\x382+8\xe6"
"\xfe\xff\xff\xe4"
"\x05\x00"
"\x00\x00\x00\x00"
"\x01\x00~\xc5,\xeb\xd1\xce"
"\xff\xffO`\x00\x05\xf6\x01"
"\x01\x00\x00\x00\x00\x00\x00\x00"
"\xfe\x00\x00\x00"
"\x01\x00P0\x00t\xf7\x82"
"\x11\x00"
"\x00\x00\x00\xff"
"x\x00\x00\x00\x00\x00\x00\x00"
"\x02\x00\x00\x00\x00\x00\x00\x00"
"\x00\x06"
"\x08\x00\x00\x00"
"\x05\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x0f"
"\x0a\x00\x00\x00\x00\x00\x00\x00"
"\xff\xffO0\x00!\xe4\x22"
"\x00\x00\x00\x10"
"\x01\xec"
"\xf6\x02\x00\x00"
"\xbe\xb0\xb2\xbe\xb6\xb1"
"LUT_OU"
"mmmmmmmmmmmm"
"\x00\x00\x00\x03"
"\x1b\x00\x00\x00"
"\x01\x00\x00\x00"
"\x01\x00\x00\x00\x00\x00\x00\x01"
"# Clea"
"\xff\x00"
"D\x00"
"\x12\x00"
"\x00\x00\x02\xf7"
"\x00\x00~\xc5,\xe3Q\xd3"
"5\x00\x00\x00"
"\xff\xff\xff\x04"
"\x01\x13"
"<\x00"
"\x10\x00"
"\x00\x01\x00\x00"
"\x00\x00~\xc5,\xa6\x1cu"
"\x0e\x05^\x01\x9f\xff\xff\xff"
"\xff\xff"
"\x00\x10"
"\x01\x00\x00\x09"
"w\x00\x00\x00\x00\x00\x00\x00"
"\x00J"
"\x00\x01"
"\xf9\x02"
"DOMAIN_MAX 1"
"\x07TITLE \xda\x11\xeek\xd6"
"\xff\xff}\xc5,\xb0h8"
"\x00\x00\x00\x00\x00\x00\x00\x01"
"\x04\x00\x00\x00"

# --- added by convert-libfuzzer-dict.py ---
"#LUT_1"
";\x00"
"\x00\x0d"
"LUT_3D"
"\x0e\x00\x00\x00\x00\x00\x00\x00"
"\xff\xffsTE\xcf\x11\xce"
"\xfe\x00"
"\x01\x00\x00\x02"
"\x01\x00"
"#!/bit"
"\x03\xeb"
"\xff\xffO0\x00#=\xd0"
"\xff\xfe"
"B\x01"
"\x0c\x0c:LUT_ID\x0c\x0c"
"\x00\x00\x00\xf6"
"\x00\x00tTE\x9f\x90\x66"
"\x04\x00"
"\x14\x00\x00\x00\x00\x00\x00\x00"
"\xd3\x00"
"\xff\xffsTE\xc8Q\xd2"
"\x00\xff"
"\x00\x00tTE\xc2\x91\xcc"
"\xf7\x02"
"\xf6\x02"
"\x1a\x00\x00\x00"
"\x01\x00\x02\xd4"
"\xa5\x00"
"+\x00\x35 0.\xb6 !!e"
"\xff\xff\x01\xe2"
"\x11\x00\x00\x00"
"TITLEclrt\x00\x00\x00"
"\xff\x0d"
"\xff\xffsTE\x88\x32|"
"DOMAIN_MAc "
"\x13\x00"
"D\x22MAIN_MAX "
"D1.0 0.0 0."
"=\x00\x00\x00"
